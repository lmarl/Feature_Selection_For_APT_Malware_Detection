##################################
# IMPORTS
##################################
import numpy as np
from numpy import *
import pandas as pd
from time import time
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.ticker import NullFormatter
from sklearn import manifold
from sklearn.manifold import TSNE
from sklearn.feature_selection import VarianceThreshold
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import chi2
from sklearn import datasets
from sklearn.ensemble import ExtraTreesClassifier
from sklearn.externals import joblib 
import sys
import numpy

##################################
# PREPARATIVOS
##################################

###Leemos el dataset
input_file="../datasets/reducido_a_1941_features_without_NaNs_y_19457_rows.csv"
output_file="resultados/codo_variance_1941.png"


df = pd.read_csv(input_file, header = 0, sep=';', dtype={"MD5":object,"FIRST_SEEN":object,"SIZE":int,"NUM_PACKERS":float64,"PACKERS_BIN":float64,"PACKERS_BIN_DIST":float64,"MALWARE_TYPE":object,"NUM_IMPORTS":float64,"IMPORTS_BIN":float64,"IMPORTS_BINARY_DIST":float64,"HAS_OVERLAYS":int,"SUSPICIOUS_DLLS":float64,"SUSPICIOUS_DLLS_DIST":float64,"ANTIDEBUG_BINARY":float64,"ANTIDEBUG_BINARY_DIST":float64,"NUM_LANG":float64,"LANG_BINARY":float64,"LANG_BINARY_DIST":float64,"API_BINARY":float64,"API_BINARY_DIST":float64,"RESOURCE_NUM":int,"SERVICES_BINARY":float64,"SERVICES_BINARY_DIST":float64,"all_files_binary":float64,"all_files_binary_DIST":float64,"all_opened_files_binary":float64,"all_opened_files_binary_DIST":float64,"all_written_files_binary":float64,"all_written_files_binary_DIST":float64,"all_deleted_files_binary":float64,"all_deleted_files_binary_DIST":float64,"all_read_files_binary":float64,"all_read_files_binary_DIST":float64,"UDP_Countries":float64,"UDP_Countries_DIST":float64,"TCP_countries":float64,"TCP_countries_DIST":float64,"DNS_countries":float64,"DNS_countries_DIST":float64,"SSDEEP":int,"IMPHASH":int,"APT":int,"NUM_APT":int})


###Separamos los campos que no nos interesan y campos objetivo
#malwaretypes=df.MALWARE_TYPE
isapt=df.APT
numapt=df.NUM_APT

###Quitamos las cabeceras de los campos objetivo
#values=malwaretypes.values.astype(np.int64)
values2=isapt.values.astype(np.int64)
values3=numapt.values.astype(np.int64)

import datetime
def convert_to_year(date_in_some_format):
	datetime_object = datetime.datetime.strptime(date_in_some_format, '%d/%m/%Y %H:%M')
	totalmins=(datetime_object-datetime.datetime(1970,1,1)).total_seconds()/60
	return int(totalmins)

#def convert_malware_type_to_new_fields(row,valor):
#   if int(row['MALWARE_TYPE']) == int(valor) :
#      return 1;
#   else:
#      return 0;

#print df.shape

#EXPLOTAMOS MALWARE_TYPE EN TIPOS:
#df['isTypeUnknown'] = df.apply (lambda row: convert_malware_type_to_new_fields(row,-1), axis=1)
#df['isOtherType'] = df.apply (lambda row: convert_malware_type_to_new_fields(row,0), axis=1)
#df['isTrojan'] = df.apply (lambda row: convert_malware_type_to_new_fields(row,1), axis=1)
#df['isWorm'] = df.apply (lambda row: convert_malware_type_to_new_fields(row,2), axis=1)
#df['isBackdoor'] = df.apply (lambda row: convert_malware_type_to_new_fields(row,3), axis=1)
#df['isRootkit'] = df.apply (lambda row: convert_malware_type_to_new_fields(row,4), axis=1)
#df['isSpyware'] = df.apply (lambda row: convert_malware_type_to_new_fields(row,5), axis=1)

#del df['MALWARE_TYPE']
#print df.shape
#exit()

#df['DATE'] = df['FIRST_SEEN'].apply(convert_to_year)
#print (df['Date'])

#del df['FIRST_SEEN']

###Quitamos los campos que no nos interesan
#del df['MALWARE_TYPE']
del df['APT']
#del df['MD5']
del df['NUM_APT']
#del df['DEVEL_GROUP']
#del df['DEVEL_COUNTRY']

#del df['IMPHASH']
#del df['SSDEEP']
#del df['DATE']

####Quitamos los campos DIST
#del df['PACKERS_BIN_DIST']
#del df['IMPORTS_BINARY_DIST']
#del df['ANTIDEBUG_BINARY_DIST']
#del df['LANG_BINARY_DIST']
#del df['API_BINARY_DIST']
#del df['SERVICES_BINARY_DIST']
##del df['all_files_binary_DIST']
#del df['all_opened_files_binary_DIST']
#del df['all_written_files_binary_DIST']
#del df['all_deleted_files_binary_DIST']
#del df['all_read_files_binary_DIST']
#del df['UDP_Countries_DIST']
#del df['TCP_countries_DIST']
#del df['DNS_countries_DIST']
#del df['SUSPICIOUS_DLLS_DIST']

#del df['PACKERS_BIN']
#del df['IMPORTS_BIN']
#del df['ANTIDEBUG_BINARY']
#del df['LANG_BINARY']
#del df['API_BINARY']
#del df['SERVICES_BINARY']
#del df['all_files_binary']
#del df['all_opened_files_binary']
#del df['all_written_files_binary']
#del df['all_deleted_files_binary']
#del df['all_read_files_binary']
#del df['UDP_Countries']
#del df['TCP_countries']
#del df['DNS_countries']
#del df['SUSPICIOUS_DLLS']

#del df['UNKNOWN1']
#del df['UNKNOWN2']
#del df['UNKNOWN3']
#del df['UNKNOWN4']
#del df['UNKNOWN5']
#del df['UNKNOWN6']
#del df['UNKNOWN7']
#del df['UNKNOWN8']
#del df['UNKNOWN9']
#del df['UNKNOWN10']
#del df['UNKNOWN11']
#del df['UNKNOWN12']
#del df['UNKNOWN13']
#del df['UNKNOWN15']
#del df['UNKNOWN16']

###Quitamos los features duplicados de imports y SUSP_APIs
#del df ['IMPORTS_BIN_CheckRemoteDebuggerPresent']
#del df ['IMPORTS_BIN_Connect']
#del df ['SUSP_API_CreateDirectoryA']
#del df ['IMPORTS_BIN_CreateFileA']
#del df ['SUSP_API_CreateProcessA']
#del df ['SUSP_API_CreateRemoteThread']
#del df ['IMPORTS_BIN_CreateThread']
#del df ['IMPORTS_BIN_DeleteFileA']
#del df ['IMPORTS_BIN_FindFirstFileA']
#del df ['IMPORTS_BIN_GetCommandLineA']
#del df ['SUSP_API_GetCurrentProcess']
#del df ['SUSP_API_GetCurrentProcessId']
#del df ['SUSP_API_GetFileAttributesA']
#del df ['IMPORTS_BIN_GetFileSize']
#del df ['IMPORTS_BIN_GetFileSizeEx']
#del df ['IMPORTS_BIN_GetModuleFileNameA']
#del df ['IMPORTS_BIN_GetModuleHandleA']
#del df ['IMPORTS_BIN_GetProcAddress']
#del df ['IMPORTS_BIN_GetStartupInfoA']
#del df ['SUSP_API_GetTempPathA']
#del df ['IMPORTS_BIN_GetThreadContext']
#del df ['IMPORTS_BIN_GetTickCount']
#del df ['IMPORTS_BIN_GetVersionExA']
#del df ['SUSP_API_IsDebuggerPresent']
#del df ['IMPORTS_BIN_LdrLoadDll']
#del df ['IMPORTS_BIN_LoadLibraryA']
#del df ['SUSP_API_MapViewOfFile']
#del df ['SUSP_API_RegCloseKey']
#del df ['IMPORTS_BIN_RegCreateKeyExA']
#del df ['IMPORTS_BIN_RegOpenKeyExA']
#del df ['IMPORTS_BIN_ShellExecuteA']
#del df ['IMPORTS_BIN_Sleep']
#del df ['IMPORTS_BIN_TerminateProcess']
#del df ['IMPORTS_BIN_UnhandledExceptionFilter']
#del df ['IMPORTS_BIN_VirtualAlloc']
#del df ['IMPORTS_BIN_VirtualFree']
#del df ['IMPORTS_BIN_VirtualProtect']
#del df ['IMPORTS_BIN_WriteFile']
#del df ['IMPORTS_BIN_WriteProcessMemory']
#del df ['SUSP_API_ZwQueryInformationThread']
#del df ['SUSP_API_FindWindowExA']
#del df ['SUSP_API_TerminateProcess']
#del df ['SUSP_API_UnhandledExceptionFilter']
#del df ['SUSP_DLLS_user32']
#del df ['IMPORTS_BIN_CreateProcess']

###Menos de 1 pero mas de 0.9:
#del df['ALL_FILES_//./Global']
#del df['IMPORTS_BIN_GetSystemDirectory']
#del df['ALL_FILES_C:/WINDOWS']
#del df['ALL_FILES_C:/WINDOWS/Registration']
#del df ['ALL_FILES_//./PIPE']
#del df ['ALL_FILES_//.']
#del df ['ALL_FILES_C:/DOCUME~1/<USER>~1/LOCALS~1/Temp']


#TAMBIEN SE QUITA SIZE POR PETICION DE ADOLFO
#del df['SIZE']

#df=df[:40]
#df=df.iloc[:,1215:1225]
print df.shape

numpy.set_printoptions(threshold=numpy.nan)
##################################
# IMPUTAMOS VALORES VACIOS
##################################
#X=joblib.load("../tmp/dataset_limpiado.joblib.pkl",  mmap_mode='r')
#X=joblib.load("../tmp/dataset_mas_completo_sin_imphash2.joblib.pkl",  mmap_mode='r')

#from sklearn.impute import SimpleImputer
#imp = SimpleImputer(strategy="most_frequent")
#imp = SimpleImputer(strategy="mean")
#X=imp.fit_transform(df)
#imputado=X

##################################
# FEATURE SELECTION
##################################
print("===================================================")
print("====Remove features with low variance (>0,9)=======")
print("===================================================")
X=df
elbow_data=[]
elbowX=[]
elbowY=[]
for i in range(1,200,1):
    thr=float(1.0*i/1000)
    Sel=VarianceThreshold(threshold=thr)
    fitt=Sel.fit(X)
    New_X=Sel.fit_transform(X)
    num,sol=New_X.shape
    print i,sol
    elbow_data.append([thr, sol])
    elbowX.append(thr)
    elbowY.append(sol)

print elbowX
print elbowY

fig, ax = plt.subplots()
ax.plot(elbowX, elbowY)
plt.savefig(output_file)
plt.show()
