import numpy as np
from numpy import *
import pandas as pd
from time import time

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.ticker import NullFormatter
from sklearn.manifold import TSNE

from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from sklearn import manifold

from sklearn.gaussian_process import GaussianProcessClassifier
from sklearn.gaussian_process.kernels import RBF

##################################
# PREPARATIVOS
##################################

###Abrimos el dataset
input_file = "../datasets/csv_con_puntos_y_con_num_APTs_final_final_conptoycoma_new_2.csv"
df = pd.read_csv(input_file, header = 0, sep=';', dtype={"MD5":object,"FIRST_SEEN":object,"SIZE":int,"NUM_PACKERS":float64,"PACKERS_BIN":float64,"PACKERS_BIN_DIST":float64,"MALWARE_TYPE":object,"NUM_IMPORTS":float64,"IMPORTS_BIN":float64,"IMPORTS_BINARY_DIST":float64,"HAS_OVERLAYS":int,"SUSPICIOUS_DLLS":float64,"SUSPICIOUS_DLLS_DIST":float64,"ANTIDEBUG_BINARY":float64,"ANTIDEBUG_BINARY_DIST":float64,"NUM_LANG":float64,"LANG_BINARY":float64,"LANG_BINARY_DIST":float64,"API_BINARY":float64,"API_BINARY_DIST":float64,"RESOURCE_NUM":int,"SERVICES_BINARY":float64,"SERVICES_BINARY_DIST":float64,"all_files_binary":float64,"all_files_binary_DIST":float64,"all_opened_files_binary":float64,"all_opened_files_binary_DIST":float64,"all_written_files_binary":float64,"all_written_files_binary_DIST":float64,"all_deleted_files_binary":float64,"all_deleted_files_binary_DIST":float64,"all_read_files_binary":float64,"all_read_files_binary_DIST":float64,"UDP_Countries":float64,"UDP_Countries_DIST":float64,"TCP_countries":float64,"TCP_countries_DIST":float64,"DNS_countries":float64,"DNS_countries_DIST":float64,"SSDEEP":int,"IMPHASH":int,"APT":int,"NUM_APT":int})

####Sacamos algunos de los campos
malwaretypes=df.MALWARE_TYPE
apttypes=df.APT
ssdeeptypes=df.SSDEEP
imphashtypes=df.IMPHASH
isapt=df.APT
numapt=df.NUM_APT

####En algunos casos hay que convertirlos a nmero:
values=malwaretypes.values.astype(np.int64)
values2=isapt.values.astype(np.int64)
values3=numapt.values.astype(np.int64)

####Y los eliminamos (no deben formar parte del dataset)
del df['MALWARE_TYPE']
del df['APT']
del df['MD5']
del df['FIRST_SEEN']
del df['SSDEEP']
del df['IMPHASH']

del df['IMPORTS_BINARY_DIST']
del df['SUSPICIOUS_DLLS_DIST']
del df['ANTIDEBUG_BINARY_DIST']
del df['LANG_BINARY_DIST']
del df['API_BINARY_DIST']
del df['SERVICES_BINARY_DIST']
del df['all_opened_files_binary_DIST']
del df['all_written_files_binary_DIST']
del df['all_read_files_binary_DIST']
del df['UDP_Countries_DIST']
del df['TCP_countries_DIST']
del df['DNS_countries_DIST']

####Creamos la figura (con un solo grafico)
fig = plt.figure(figsize=(15, 15))
ax = fig.add_subplot(1, 1, 1)

##################################
# Standarization
##################################
from sklearn import preprocessing
atributos=list(df)
df2 = preprocessing.scale(df)
df = pd.DataFrame(df2)

#df.drop(axis=1, columns=1)

##################################
# TSNE
##################################
# Cargamos fichero con los datos del TSNE
#
output_dir="../tmp"
output_filename = output_dir + '/tsne_nuevo_con15.npy'
Y = np.load(output_filename)

apts=Y[np.where( values2 > 0 )] 
isapts=values2[np.where( values2 > 0 )]
print(isapts)

clf=GaussianProcessClassifier(1.0 * RBF(1.0))
#######################
#LO MOSTRAMOS POR APT (Si/No)
perpl=30

#Estas son las APTs que manejamos:
target_names=['Malware', 'APT']

#Y estos los colores que asignaremos a cada APT:
colors=['Red','Green']

#Tenemos 27 APTs
number_of_APTs=27

#Pero tambien vamos a considerar el malware generico... asi que 28
list_length=number_of_APTs+1

#Estos son los codigos de las APTs que hay en el CSV, como vemos no son consecutivos porque se han ido quitando algunos con el tiempo
target=[0,1]

lista=[0,1]
#lista=range(0,list_length+1)


plt.title("t-SNE (perplexity: %.2g)" % (perpl))
plt.legend(bbox_to_anchor=(0.98,0.98))

###LANZAMOS EL KMEANS
#reduced_data = PCA(n_components=2).fit_transform(df)
#reduced_data = PCA(n_components=2).fit_transform(Y)

NCLUSTERS=6

kmeans = KMeans(n_clusters=NCLUSTERS, random_state=0).fit(apts)

h = 1     # point in the mesh [x_min, x_max]x[y_min, y_max].
# Plot the decision boundary. For that, we will assign a color to each
x_min, x_max = Y[:, 0].min() - 1, Y[:, 0].max() + 1
y_min, y_max = Y[:, 1].min() - 1, Y[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))
Z = kmeans.predict(np.c_[xx.ravel(), yy.ravel()])

Z = Z.reshape(xx.shape)

plt.figure(1)
plt.clf()

centroids = kmeans.cluster_centers_
plt.imshow(Z, interpolation='nearest',
           extent=(xx.min(), xx.max(), yy.min(), yy.max()),
           cmap=plt.cm.Paired,
           aspect='auto', origin='lower')
plt.scatter(centroids[:, 0], centroids[:, 1], marker='x', s=169, linewidths=3, color='b', zorder=10)
#for color, i, target_name, pos in zip(colors, target, target_names, lista):
#               	plt.scatter(apts[:, 0], apts[:, 1], cmap=plt.cm.Spectral, s=1, c=color, label=target_names[pos])


for color, i, target_name, pos in zip(colors, target, target_names, lista):
                indices=[]
                paraimprimir=[]

                for index in range(0,Y.size/2):
                        if values2[index]==i:
                                indices=np.append(indices,index)

                indices2=indices.astype(np.int64)
                paraimprimir=Y[indices2]
                if pos==0:
                        plt.scatter(paraimprimir[:, 0], paraimprimir[:, 1], cmap=plt.cm.Spectral, s=1, c=color, label=target_names[pos])
                else:
                        plt.scatter(paraimprimir[:, 0], paraimprimir[:, 1], cmap=plt.cm.Spectral, s=4, c=color, label=target_names[pos])

##################################
# SHOW PLOT
##################################
ax.xaxis.set_major_formatter(NullFormatter())
ax.yaxis.set_major_formatter(NullFormatter())
plt.axis('tight')
fig.savefig('resultados/Fig_Centroides_By_APT_Y_Malware.png')
plt.show()
