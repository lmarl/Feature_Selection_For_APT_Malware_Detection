import numpy as np
from numpy import *
import pandas as pd
from time import time

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.ticker import NullFormatter

from sklearn import manifold
input_file = "../datasets/csv_con_puntos_y_con_num_APTs_final_final_conptoycoma.csv"

df2 = pd.read_csv(input_file, header = 0, sep=';', dtype={"MD5":object,"FIRST_SEEN":object,"SIZE":int,"NUM_PACKERS":float64,"PACKERS_BIN":float64,"PACKERS_BIN_DIST":float64,"MALWARE_TYPE":object,"NUM_IMPORTS":float64,"IMPORTS_BIN":float64,"IMPORTS_BINARY_DIST":float64,"HAS_OVERLAYS":int,"SUSPICIOUS_DLLS":float64,"SUSPICIOUS_DLLS_DIST":float64,"ANTIDEBUG_BINARY":float64,"ANTIDEBUG_BINARY_DIST":float64,"NUM_LANG":float64,"LANG_BINARY":float64,"LANG_BINARY_DIST":float64,"API_BINARY":float64,"API_BINARY_DIST":float64,"RESOURCE_NUM":int,"SERVICES_BINARY":float64,"SERVICES_BINARY_DIST":float64,"all_files_binary":float64,"all_files_binary_DIST":float64,"all_opened_files_binary":float64,"all_opened_files_binary_DIST":float64,"all_written_files_binary":float64,"all_written_files_binary_DIST":float64,"all_deleted_files_binary":float64,"all_deleted_files_binary_DIST":float64,"all_read_files_binary":float64,"all_read_files_binary_DIST":float64,"UDP_Countries":float64,"UDP_Countries_DIST":float64,"TCP_countries":float64,"TCP_countries_DIST":float64,"DNS_countries":float64,"DNS_countries_DIST":float64,"SSDEEP":int,"IMPHASH":int,"APT":int,"NUM_APT":int})

df=df2

malwaretypes=df.MALWARE_TYPE
ssdeeptypes=df.SSDEEP
imphashtypes=df.IMPHASH
apttypes=df.APT
numapt=df.NUM_APT

values=malwaretypes.values.astype(np.int64)
values2=apttypes.values.astype(np.int64)
values3=numapt.values.astype(np.int64)

#del df['MALWARE_TYPE']
del df['APT']
del df['MD5']
del df['FIRST_SEEN']
del df['SSDEEP']
del df['IMPHASH']
del df['NUM_APT']

#df.drop(axis=1, columns=1)
df3=df.values
#print df3


output_dir="../tmp"
output_filename = output_dir + '/tsne_solo24_perpl30.npy'

##################################
# TSNE
##################################
#tsne_data = np.load(output_filename)
#ej=tsne_data[20546]

#print tsne_data.shape
#print apttypes.shape

##################################
# Preparando Training y Testing sets
##################################
shuffle_index=np.random.permutation(17000)
df=df.values
X_train,X_test,Y_train,Y_test=df[:17000],df[17000:],apttypes[:17000],apttypes[17000:]

#####TARGET VECTORS#######
Y_train_APT=(Y_train == 1)
Y_test_APT=(Y_test == 1)

###########################################
# SGD Classifier
###########################################
from sklearn.linear_model import SGDClassifier
sgd_clf = SGDClassifier(random_state=12)
sgd_clf.fit(X_train, Y_train_APT)

acierto=0
total=0
for i in range(17000,20547):
	total=total+1
	ej=df3[i]
	prediction=sgd_clf.predict([ej])

	#print i, prediction, apttypes[i]
	if (prediction) and apttypes[i]==1:
		acierto=acierto + 1
	if (not prediction) and apttypes[i]==0:
		acierto=acierto + 1
media=100*acierto / total
print acierto," aciertos de ",total,"intentos (",media,"%)"


###########################################
# Cross Validation
###########################################

from sklearn.model_selection import StratifiedKFold
from sklearn.base import clone

skfolds=StratifiedKFold(n_splits=7, random_state=42)

print ("\nIntentamos con 7 Kfolds. Los porcentajes de acierto son:")
for train_index, test_index in skfolds.split(X_train, Y_train_APT):
	clone_clf=clone(sgd_clf)
	X_train_folds=X_train[train_index]
	Y_train_folds = Y_train_APT[train_index]

	X_test_fold = X_train[test_index]
	Y_test_fold = Y_train_APT[test_index]

	clone_clf.fit(X_train_folds, Y_train_folds)
	y_pred=clone_clf.predict(X_test_fold)
	#print y_pred.shape
	#print Y_test_fold.shape
	n_correct=sum(y_pred==Y_test_fold)
	#print n_correct
	resultado=0,01
	resultado=100.0*n_correct/len(y_pred)
	print resultado

###########
# Cross Validation de SKLEARN
###########
from sklearn.model_selection import cross_val_score
print "\nCross Validation de SKLEARN. Lo intentamos con 3 valores:"
print cross_val_score(sgd_clf, X_train, Y_train_APT, cv=3, scoring="accuracy")

###########
# Confusion Matrix
###########
from sklearn.model_selection import cross_val_predict
from sklearn.metrics import confusion_matrix
y_test_pred=cross_val_predict(sgd_clf, X_test, Y_test_APT, cv=10)

print "\nConfusion Matrix"
print confusion_matrix(Y_test_APT,y_test_pred)

###########
# Precision and recall
###########
from sklearn.metrics import precision_score, recall_score
print "\nprecision score"
print precision_score(Y_test_APT, y_test_pred)
print "\nrecall score"
print recall_score(Y_test_APT, y_test_pred)


###########
# Precision/recall tradeoff
#
# Esta grafica nos permite determinar cual es el mejor threshold(donde se crucen las curvas). Ver pag 90
###########
#from sklearn.metrics import precision_recall_curve
#
#fig = plt.figure(figsize=(15, 15))
#
y_scores=cross_val_predict(sgd_clf, X_train, Y_train_APT, cv=3, method="decision_function")
#precisions, recalls, thresholds=precision_recall_curve(Y_train_APT, y_scores)
#
#plt.plot(thresholds, precisions[:-1], "b--", label="Precision")
#plt.plot(thresholds, recalls[:-1],"g-", label="Recall")
#plt.xlabel("Threshold")
#plt.legend(loc="center left")
#plt.ylim([0,1])
#
#plt.show()

###########
# ROC Curve
#
# Esta grafica nos permite decidir cual de los clasificadores son mejores
###########
from sklearn.metrics import roc_curve

print "\nROC Curve"
fig = plt.figure(figsize=(15, 15))
for i in range(3,16):
	y_scores=cross_val_predict(sgd_clf, X_train, Y_train_APT, cv=i, method="decision_function")
	fpr, tpr, thresholds=roc_curve(Y_train_APT,y_scores)
	plt.plot(fpr, tpr, linewidth=2, label=str(i))
plt.plot([0,1],[0,1],"k--")
plt.axis([0,1,0,1])
plt.xlabel("False Positive rate")
plt.ylabel("True Positive rate")
plt.legend()
plt.show()
plt.savefig('resultados/kfolding_con_SGD_ROC_Curves.png')

###########
# ROC AUC Score
###########
from sklearn.metrics import roc_auc_score

print "\nROC AUC Score"
print roc_auc_score(Y_train_APT, y_scores)
#fpr, tpr, thresholds=roc_curve(Y_train_APT,y_scores)


#print precision_score(Y_train_APT, y_train_pred)
